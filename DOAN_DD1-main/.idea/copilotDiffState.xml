<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/da/adapter/SubjectAdapter.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/da/adapter/SubjectAdapter.kt" />
              <option name="updatedContent" value="package com.example.da.adapter&#10;&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.TextView&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.da.R&#10;import com.example.da.model.Subject&#10;&#10;class SubjectAdapter(&#10;    private var subjects: List&lt;Subject&gt;,&#10;    private val onEditClick: (Subject) -&gt; Unit,&#10;    private val onDeleteClick: (Subject) -&gt; Unit&#10;) : RecyclerView.Adapter&lt;SubjectAdapter.SubjectViewHolder&gt;() {&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): SubjectViewHolder {&#10;        val view = LayoutInflater.from(parent.context).inflate(R.layout.item_subject, parent, false)&#10;        return SubjectViewHolder(view)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: SubjectViewHolder, position: Int) {&#10;        val subject = subjects[position]&#10;        holder.bind(subject, onEditClick, onDeleteClick)&#10;    }&#10;&#10;    override fun getItemCount(): Int = subjects.size&#10;&#10;    fun updateSubjects(newSubjects: List&lt;Subject&gt;) {&#10;        subjects = newSubjects&#10;        notifyDataSetChanged()&#10;    }&#10;&#10;    class SubjectViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {&#10;        private val tvSubjectName: TextView = itemView.findViewById(R.id.tvSubjectName)&#10;        private val btnEdit: Button = itemView.findViewById(R.id.btnEdit)&#10;        private val btnDelete: Button = itemView.findViewById(R.id.btnDelete)&#10;&#10;        fun bind(subject: Subject, onEditClick: (Subject) -&gt; Unit, onDeleteClick: (Subject) -&gt; Unit) {&#10;            tvSubjectName.text = subject.name&#10;            btnEdit.setOnClickListener { onEditClick(subject) }&#10;            btnDelete.setOnClickListener { onDeleteClick(subject) }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/da/database/DatabaseHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/da/database/DatabaseHelper.kt" />
              <option name="originalContent" value="package com.example.da.database&#10;&#10;import android.annotation.SuppressLint&#10;import android.content.ContentValues&#10;import android.content.Context&#10;import android.database.sqlite.SQLiteDatabase&#10;import android.database.sqlite.SQLiteOpenHelper&#10;import com.example.da.model.Answer&#10;import com.example.da.model.Question&#10;import com.example.da.model.Subject&#10;import com.example.da.model.Test&#10;import com.example.da.model.TestResult&#10;&#10;class DatabaseHelper(context: Context) : SQLiteOpenHelper(context, DATABASE_NAME, null, DATABASE_VERSION) {&#10;&#10;    companion object {&#10;        private const val DATABASE_NAME = &quot;QuizApp.db&quot;&#10;        private const val DATABASE_VERSION = 5 // Incremented to trigger onUpgrade&#10;&#10;        // Table Subjects&#10;        private const val TABLE_SUBJECTS = &quot;subjects&quot;&#10;        private const val COLUMN_ID = &quot;id&quot;&#10;        private const val COLUMN_NAME = &quot;name&quot;&#10;        private const val COLUMN_CREATED_AT = &quot;created_at&quot;&#10;&#10;        // Table Questions&#10;        private const val TABLE_QUESTIONS = &quot;questions&quot;&#10;        private const val COLUMN_QUESTION_ID = &quot;question_id&quot;&#10;        private const val COLUMN_SUBJECT_ID = &quot;subject_id&quot;&#10;        private const val COLUMN_QUESTION_TEXT = &quot;question_text&quot;&#10;        private const val COLUMN_DIFFICULTY = &quot;difficulty&quot;&#10;        private const val COLUMN_IS_MULTIPLE_CHOICE = &quot;is_multiple_choice&quot;&#10;&#10;        // Table Answers&#10;        private const val TABLE_ANSWERS = &quot;answers&quot;&#10;        private const val COLUMN_ANSWER_ID = &quot;answer_id&quot;&#10;        private const val COLUMN_ANSWER_QUESTION_ID = &quot;question_id&quot;&#10;        private const val COLUMN_ANSWER_TEXT = &quot;answer_text&quot;&#10;        private const val COLUMN_IS_CORRECT = &quot;is_correct&quot;&#10;&#10;        // Table Tests&#10;        private const val TABLE_TESTS = &quot;tests&quot;&#10;        private const val COLUMN_TEST_ID = &quot;test_id&quot;&#10;        private const val COLUMN_TEST_SUBJECT_ID = &quot;subject_id&quot;&#10;        private const val COLUMN_TEST_NAME = &quot;name&quot;&#10;        private const val COLUMN_NUM_QUESTIONS = &quot;num_questions&quot;&#10;        private const val COLUMN_DURATION_MINUTES = &quot;duration_minutes&quot;&#10;        private const val COLUMN_ALLOW_MULTIPLE_ANSWERS = &quot;allow_multiple_answers&quot;&#10;        private const val COLUMN_EASY_PERCENT = &quot;easy_percent&quot;&#10;        private const val COLUMN_MEDIUM_PERCENT = &quot;medium_percent&quot;&#10;        private const val COLUMN_HARD_PERCENT = &quot;hard_percent&quot;&#10;        private const val COLUMN_TEST_CREATED_AT = &quot;created_at&quot;&#10;&#10;        // Table TestResults&#10;        private const val TABLE_TEST_RESULTS = &quot;test_results&quot;&#10;        private const val COLUMN_RESULT_ID = &quot;result_id&quot;&#10;        private const val COLUMN_RESULT_TEST_ID = &quot;test_id&quot;&#10;        private const val COLUMN_SCORE = &quot;score&quot;&#10;        private const val COLUMN_TIME_TAKEN_SECONDS = &quot;time_taken_seconds&quot;&#10;        private const val COLUMN_RESULT_CREATED_AT = &quot;created_at&quot;&#10;    }&#10;&#10;    override fun onCreate(db: SQLiteDatabase?) {&#10;        val createSubjectsTable = &quot;&quot;&quot;&#10;            CREATE TABLE $TABLE_SUBJECTS (&#10;                $COLUMN_ID INTEGER PRIMARY KEY AUTOINCREMENT,&#10;                $COLUMN_NAME TEXT NOT NULL UNIQUE,&#10;                $COLUMN_CREATED_AT INTEGER NOT NULL&#10;            )&#10;        &quot;&quot;&quot;.trimIndent()&#10;&#10;        val createQuestionsTable = &quot;&quot;&quot;&#10;            CREATE TABLE $TABLE_QUESTIONS (&#10;                $COLUMN_QUESTION_ID INTEGER PRIMARY KEY AUTOINCREMENT,&#10;                $COLUMN_SUBJECT_ID INTEGER NOT NULL,&#10;                $COLUMN_QUESTION_TEXT TEXT NOT NULL,&#10;                $COLUMN_DIFFICULTY TEXT NOT NULL,&#10;                $COLUMN_IS_MULTIPLE_CHOICE INTEGER NOT NULL,&#10;                FOREIGN KEY($COLUMN_SUBJECT_ID) REFERENCES $TABLE_SUBJECTS($COLUMN_ID)&#10;            )&#10;        &quot;&quot;&quot;.trimIndent()&#10;&#10;        val createAnswersTable = &quot;&quot;&quot;&#10;            CREATE TABLE $TABLE_ANSWERS (&#10;                $COLUMN_ANSWER_ID INTEGER PRIMARY KEY AUTOINCREMENT,&#10;                $COLUMN_ANSWER_QUESTION_ID INTEGER NOT NULL,&#10;                $COLUMN_ANSWER_TEXT TEXT NOT NULL,&#10;                $COLUMN_IS_CORRECT INTEGER NOT NULL,&#10;                FOREIGN KEY($COLUMN_ANSWER_QUESTION_ID) REFERENCES $TABLE_QUESTIONS($COLUMN_QUESTION_ID)&#10;            )&#10;        &quot;&quot;&quot;.trimIndent()&#10;&#10;        val createTestsTable = &quot;&quot;&quot;&#10;            CREATE TABLE $TABLE_TESTS (&#10;                $COLUMN_TEST_ID INTEGER PRIMARY KEY AUTOINCREMENT,&#10;                $COLUMN_TEST_SUBJECT_ID INTEGER NOT NULL,&#10;                $COLUMN_TEST_NAME TEXT NOT NULL,&#10;                $COLUMN_NUM_QUESTIONS INTEGER NOT NULL,&#10;                $COLUMN_DURATION_MINUTES INTEGER NOT NULL,&#10;                $COLUMN_ALLOW_MULTIPLE_ANSWERS INTEGER NOT NULL,&#10;                $COLUMN_EASY_PERCENT INTEGER NOT NULL,&#10;                $COLUMN_MEDIUM_PERCENT INTEGER NOT NULL,&#10;                $COLUMN_HARD_PERCENT INTEGER NOT NULL,&#10;                $COLUMN_TEST_CREATED_AT INTEGER NOT NULL,&#10;                FOREIGN KEY($COLUMN_TEST_SUBJECT_ID) REFERENCES $TABLE_SUBJECTS($COLUMN_ID)&#10;            )&#10;        &quot;&quot;&quot;.trimIndent()&#10;&#10;        val createTestResultsTable = &quot;&quot;&quot;&#10;            CREATE TABLE $TABLE_TEST_RESULTS (&#10;                $COLUMN_RESULT_ID INTEGER PRIMARY KEY AUTOINCREMENT,&#10;                $COLUMN_RESULT_TEST_ID INTEGER NOT NULL,&#10;                $COLUMN_SCORE INTEGER NOT NULL,&#10;                $COLUMN_TIME_TAKEN_SECONDS INTEGER NOT NULL,&#10;                $COLUMN_RESULT_CREATED_AT INTEGER NOT NULL,&#10;                FOREIGN KEY($COLUMN_RESULT_TEST_ID) REFERENCES $TABLE_TESTS($COLUMN_TEST_ID)&#10;            )&#10;        &quot;&quot;&quot;.trimIndent()&#10;&#10;        db?.execSQL(createSubjectsTable)&#10;        db?.execSQL(createQuestionsTable)&#10;        db?.execSQL(createAnswersTable)&#10;        db?.execSQL(createTestsTable)&#10;        db?.execSQL(createTestResultsTable)&#10;        addSampleData(db)&#10;    }&#10;&#10;    override fun onUpgrade(db: SQLiteDatabase?, oldVersion: Int, newVersion: Int) {&#10;        db?.execSQL(&quot;DROP TABLE IF EXISTS $TABLE_ANSWERS&quot;)&#10;        db?.execSQL(&quot;DROP TABLE IF EXISTS $TABLE_QUESTIONS&quot;)&#10;        db?.execSQL(&quot;DROP TABLE IF EXISTS $TABLE_TESTS&quot;)&#10;        db?.execSQL(&quot;DROP TABLE IF EXISTS $TABLE_TEST_RESULTS&quot;)&#10;        db?.execSQL(&quot;DROP TABLE IF EXISTS $TABLE_SUBJECTS&quot;)&#10;        onCreate(db)&#10;    }&#10;&#10;    private fun addSampleData(db: SQLiteDatabase?) {&#10;        // Add sample subjects&#10;        val sampleSubjects = listOf(&quot;Toán&quot;, &quot;Vật Lý&quot;, &quot;Hóa Học&quot;, &quot;Tiếng Anh&quot;)&#10;        val subjectIds = mutableListOf&lt;Long&gt;()&#10;        sampleSubjects.forEach { subjectName -&gt;&#10;            val values = ContentValues().apply {&#10;                put(COLUMN_NAME, subjectName)&#10;                put(COLUMN_CREATED_AT, System.currentTimeMillis())&#10;            }&#10;            val id = db?.insert(TABLE_SUBJECTS, null, values)&#10;            id?.let { subjectIds.add(it) }&#10;        }&#10;&#10;        // Add sample tests if subjects were added&#10;        if (subjectIds.isNotEmpty()) {&#10;            val test1 = ContentValues().apply {&#10;                put(COLUMN_TEST_SUBJECT_ID, subjectIds[0]) // Toán&#10;                put(COLUMN_TEST_NAME, &quot;Đề kiểm tra giữa kỳ Toán&quot;)&#10;                put(COLUMN_NUM_QUESTIONS, 15)&#10;                put(COLUMN_DURATION_MINUTES, 45)&#10;                put(COLUMN_ALLOW_MULTIPLE_ANSWERS, 0)&#10;                put(COLUMN_EASY_PERCENT, 40)&#10;                put(COLUMN_MEDIUM_PERCENT, 40)&#10;                put(COLUMN_HARD_PERCENT, 20)&#10;                put(COLUMN_TEST_CREATED_AT, System.currentTimeMillis())&#10;            }&#10;            db?.insert(TABLE_TESTS, null, test1)&#10;&#10;            val test2 = ContentValues().apply {&#10;                put(COLUMN_TEST_SUBJECT_ID, subjectIds[1]) // Vật Lý&#10;                put(COLUMN_TEST_NAME, &quot;Đề thi cuối kỳ Vật Lý&quot;)&#10;                put(COLUMN_NUM_QUESTIONS, 20)&#10;                put(COLUMN_DURATION_MINUTES, 60)&#10;                put(COLUMN_ALLOW_MULTIPLE_ANSWERS, 0)&#10;                put(COLUMN_EASY_PERCENT, 30)&#10;                put(COLUMN_MEDIUM_PERCENT, 50)&#10;                put(COLUMN_HARD_PERCENT, 20)&#10;                put(COLUMN_TEST_CREATED_AT, System.currentTimeMillis())&#10;            }&#10;            db?.insert(TABLE_TESTS, null, test2)&#10;        }&#10;    }&#10;&#10;    fun addSubject(subject: Subject): Long {&#10;        val db = writableDatabase&#10;        val values = ContentValues().apply {&#10;            put(COLUMN_NAME, subject.name)&#10;            put(COLUMN_CREATED_AT, System.currentTimeMillis())&#10;        }&#10;        val id = db.insert(TABLE_SUBJECTS, null, values)&#10;        return id&#10;    }&#10;&#10;    @SuppressLint(&quot;Range&quot;)&#10;    fun getAllSubjects(): List&lt;Subject&gt; {&#10;        val subjects = mutableListOf&lt;Subject&gt;()&#10;        val db = readableDatabase&#10;        val cursor = db.rawQuery(&quot;SELECT * FROM $TABLE_SUBJECTS ORDER BY $COLUMN_CREATED_AT DESC&quot;, null)&#10;        if (cursor.moveToFirst()) {&#10;            do {&#10;                val subject = Subject(&#10;                    id = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_ID)),&#10;                    name = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_NAME)),&#10;                    createdAt = cursor.getLong(cursor.getColumnIndexOrThrow(COLUMN_CREATED_AT))&#10;                )&#10;                subjects.add(subject)&#10;            } while (cursor.moveToNext())&#10;        }&#10;        cursor.close()&#10;        return subjects&#10;    }&#10;&#10;    fun deleteSubject(id: Int): Int {&#10;        val db = writableDatabase&#10;        val result = db.delete(TABLE_SUBJECTS, &quot;$COLUMN_ID = ?&quot;, arrayOf(id.toString()))&#10;        return result&#10;    }&#10;&#10;    @SuppressLint(&quot;Range&quot;)&#10;    fun isSubjectExists(name: String): Boolean {&#10;        val db = readableDatabase&#10;        val query = &quot;SELECT COUNT(*) FROM $TABLE_SUBJECTS WHERE $COLUMN_NAME = ?&quot;&#10;        val cursor = db.rawQuery(query, arrayOf(name))&#10;        var exists = false&#10;        if (cursor.moveToFirst()) {&#10;            exists = cursor.getInt(0) &gt; 0&#10;        }&#10;        cursor.close()&#10;        return exists&#10;    }&#10;&#10;    fun deleteQuestion(questionId: Int): Int {&#10;        val db = writableDatabase&#10;        db.delete(TABLE_ANSWERS, &quot;$COLUMN_ANSWER_QUESTION_ID = ?&quot;, arrayOf(questionId.toString()))&#10;        val result = db.delete(TABLE_QUESTIONS, &quot;$COLUMN_QUESTION_ID = ?&quot;, arrayOf(questionId.toString()))&#10;        return result&#10;    }&#10;&#10;    fun addQuestion(subjectId: Int, questionText: String, difficulty: String, isMultipleChoice: Boolean, answers: List&lt;Pair&lt;String, Boolean&gt;&gt;): Long {&#10;        val db = writableDatabase&#10;        val questionValues = ContentValues().apply {&#10;            put(COLUMN_SUBJECT_ID, subjectId)&#10;            put(COLUMN_QUESTION_TEXT, questionText)&#10;            put(COLUMN_DIFFICULTY, difficulty)&#10;            put(COLUMN_IS_MULTIPLE_CHOICE, if (isMultipleChoice) 1 else 0)&#10;        }&#10;        val questionId = db.insert(TABLE_QUESTIONS, null, questionValues)&#10;&#10;        if (questionId &gt; 0) {&#10;            for ((answerText, isCorrect) in answers) {&#10;                val answerValues = ContentValues().apply {&#10;                    put(COLUMN_ANSWER_QUESTION_ID, questionId)&#10;                    put(COLUMN_ANSWER_TEXT, answerText)&#10;                    put(COLUMN_IS_CORRECT, if (isCorrect) 1 else 0)&#10;                }&#10;                db.insert(TABLE_ANSWERS, null, answerValues)&#10;            }&#10;        }&#10;        return questionId&#10;    }&#10;&#10;    @SuppressLint(&quot;Range&quot;)&#10;    fun getQuestionsBySubject(subjectId: Int): List&lt;Question&gt; {&#10;        val questions = mutableListOf&lt;Question&gt;()&#10;        val db = readableDatabase&#10;        val cursor = db.rawQuery(&quot;SELECT * FROM $TABLE_QUESTIONS WHERE $COLUMN_SUBJECT_ID = ?&quot;, arrayOf(subjectId.toString()))&#10;        if (cursor.moveToFirst()) {&#10;            do {&#10;                val question = Question(&#10;                    id = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_QUESTION_ID)),&#10;                    subjectId = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_SUBJECT_ID)),&#10;                    text = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_QUESTION_TEXT)),&#10;                    difficulty = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_DIFFICULTY)),&#10;                    isMultipleChoice = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_IS_MULTIPLE_CHOICE)) == 1&#10;                )&#10;                questions.add(question)&#10;            } while (cursor.moveToNext())&#10;        }&#10;        cursor.close()&#10;        return questions&#10;    }&#10;&#10;    fun addTest(test: Test): Long {&#10;        val db = writableDatabase&#10;        val values = ContentValues().apply {&#10;            put(COLUMN_TEST_SUBJECT_ID, test.subjectId)&#10;            put(COLUMN_TEST_NAME, test.name)&#10;            put(COLUMN_NUM_QUESTIONS, test.numQuestions)&#10;            put(COLUMN_DURATION_MINUTES, test.durationMinutes)&#10;            put(COLUMN_ALLOW_MULTIPLE_ANSWERS, if (test.allowMultipleAnswers) 1 else 0)&#10;            put(COLUMN_EASY_PERCENT, test.easyPercent)&#10;            put(COLUMN_MEDIUM_PERCENT, test.mediumPercent)&#10;            put(COLUMN_HARD_PERCENT, test.hardPercent)&#10;            put(COLUMN_TEST_CREATED_AT, test.createdAt)&#10;        }&#10;        val id = db.insert(TABLE_TESTS, null, values)&#10;        return id&#10;    }&#10;&#10;    @SuppressLint(&quot;Range&quot;)&#10;    fun getAllTests(): List&lt;Test&gt; {&#10;        val tests = mutableListOf&lt;Test&gt;()&#10;        val db = readableDatabase&#10;        val query = &quot;&quot;&quot;&#10;            SELECT t.*, s.$COLUMN_NAME as subject_name&#10;            FROM $TABLE_TESTS t &#10;            JOIN $TABLE_SUBJECTS s ON t.$COLUMN_TEST_SUBJECT_ID = s.$COLUMN_ID &#10;            ORDER BY t.$COLUMN_TEST_CREATED_AT DESC&#10;        &quot;&quot;&quot;.trimIndent()&#10;&#10;        val cursor = db.rawQuery(query, null)&#10;&#10;        if (cursor.moveToFirst()) {&#10;            do {&#10;                val test = Test(&#10;                    testId = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_TEST_ID)),&#10;                    subjectId = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_TEST_SUBJECT_ID)),&#10;                    name = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_TEST_NAME)),&#10;                    numQuestions = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_NUM_QUESTIONS)),&#10;                    durationMinutes = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_DURATION_MINUTES)),&#10;                    allowMultipleAnswers = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_ALLOW_MULTIPLE_ANSWERS)) == 1,&#10;                    easyPercent = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_EASY_PERCENT)),&#10;                    mediumPercent = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_MEDIUM_PERCENT)),&#10;                    hardPercent = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_HARD_PERCENT)),&#10;                    createdAt = cursor.getLong(cursor.getColumnIndexOrThrow(COLUMN_TEST_CREATED_AT)),&#10;                    subjectName = cursor.getString(cursor.getColumnIndexOrThrow(&quot;subject_name&quot;))&#10;                )&#10;                tests.add(test)&#10;            } while (cursor.moveToNext())&#10;        }&#10;        cursor.close()&#10;        return tests&#10;    }&#10;&#10;    @SuppressLint(&quot;Range&quot;)&#10;    fun getTestById(testId: Int): Test? {&#10;        val db = readableDatabase&#10;        val query = &quot;&quot;&quot;&#10;            SELECT t.*, s.$COLUMN_NAME as subject_name&#10;            FROM $TABLE_TESTS t &#10;            JOIN $TABLE_SUBJECTS s ON t.$COLUMN_TEST_SUBJECT_ID = s.$COLUMN_ID &#10;            WHERE t.$COLUMN_TEST_ID = ?&#10;        &quot;&quot;&quot;.trimIndent()&#10;        val cursor = db.rawQuery(query, arrayOf(testId.toString()))&#10;        var test: Test? = null&#10;        if (cursor.moveToFirst()) {&#10;            test = Test(&#10;                testId = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_TEST_ID)),&#10;                subjectId = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_TEST_SUBJECT_ID)),&#10;                name = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_TEST_NAME)),&#10;                numQuestions = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_NUM_QUESTIONS)),&#10;                durationMinutes = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_DURATION_MINUTES)),&#10;                allowMultipleAnswers = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_ALLOW_MULTIPLE_ANSWERS)) == 1,&#10;                easyPercent = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_EASY_PERCENT)),&#10;                mediumPercent = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_MEDIUM_PERCENT)),&#10;                hardPercent = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_HARD_PERCENT)),&#10;                createdAt = cursor.getLong(cursor.getColumnIndexOrThrow(COLUMN_TEST_CREATED_AT)),&#10;                subjectName = cursor.getString(cursor.getColumnIndexOrThrow(&quot;subject_name&quot;))&#10;            )&#10;        }&#10;        cursor.close()&#10;        return test&#10;    }&#10;&#10;    @SuppressLint(&quot;Range&quot;)&#10;    fun getQuestionsForTest(test: Test): List&lt;Question&gt; {&#10;        val questions = mutableListOf&lt;Question&gt;()&#10;        val db = readableDatabase&#10;&#10;        val numEasy = (test.numQuestions * (test.easyPercent / 100.0)).toInt()&#10;        val numMedium = (test.numQuestions * (test.mediumPercent / 100.0)).toInt()&#10;        val numHard = test.numQuestions - numEasy - numMedium&#10;&#10;        val easyQuestions = getQuestionsByDifficulty(db, test.subjectId, &quot;Dễ&quot;, numEasy)&#10;        val mediumQuestions = getQuestionsByDifficulty(db, test.subjectId, &quot;Trung bình&quot;, numMedium)&#10;        val hardQuestions = getQuestionsByDifficulty(db, test.subjectId, &quot;Khó&quot;, numHard)&#10;&#10;        questions.addAll(easyQuestions)&#10;        questions.addAll(mediumQuestions)&#10;        questions.addAll(hardQuestions)&#10;&#10;        return questions.shuffled()&#10;    }&#10;&#10;    @SuppressLint(&quot;Range&quot;)&#10;    private fun getQuestionsByDifficulty(db: SQLiteDatabase, subjectId: Int, difficulty: String, limit: Int): List&lt;Question&gt; {&#10;        val questions = mutableListOf&lt;Question&gt;()&#10;        val query = &quot;SELECT * FROM $TABLE_QUESTIONS WHERE $COLUMN_SUBJECT_ID = ? AND $COLUMN_DIFFICULTY = ? ORDER BY RANDOM() LIMIT ?&quot;&#10;        val cursor = db.rawQuery(query, arrayOf(subjectId.toString(), difficulty, limit.toString()))&#10;        if (cursor.moveToFirst()) {&#10;            do {&#10;                val question = Question(&#10;                    id = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_QUESTION_ID)),&#10;                    subjectId = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_SUBJECT_ID)),&#10;                    text = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_QUESTION_TEXT)),&#10;                    difficulty = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_DIFFICULTY)),&#10;                    isMultipleChoice = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_IS_MULTIPLE_CHOICE)) == 1&#10;                )&#10;                questions.add(question)&#10;            } while (cursor.moveToNext())&#10;        }&#10;        cursor.close()&#10;        return questions&#10;    }&#10;&#10;    @SuppressLint(&quot;Range&quot;)&#10;    fun getAnswersByQuestion(questionId: Int): List&lt;Answer&gt; {&#10;        val answers = mutableListOf&lt;Answer&gt;()&#10;        val db = readableDatabase&#10;        val cursor = db.rawQuery(&quot;SELECT * FROM $TABLE_ANSWERS WHERE $COLUMN_ANSWER_QUESTION_ID = ?&quot;, arrayOf(questionId.toString()))&#10;        if (cursor.moveToFirst()) {&#10;            do {&#10;                val answer = Answer(&#10;                    id = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_ANSWER_ID)),&#10;                    questionId = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_ANSWER_QUESTION_ID)),&#10;                    answerText = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_ANSWER_TEXT)),&#10;                    isCorrect = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_IS_CORRECT)) == 1&#10;                )&#10;                answers.add(answer)&#10;            } while (cursor.moveToNext())&#10;        }&#10;        cursor.close()&#10;        return answers&#10;    }&#10;&#10;    fun addTestResult(testResult: TestResult): Long {&#10;        val db = writableDatabase&#10;        val values = ContentValues().apply {&#10;            put(COLUMN_RESULT_TEST_ID, testResult.testId)&#10;            put(COLUMN_SCORE, testResult.score)&#10;            put(COLUMN_TIME_TAKEN_SECONDS, testResult.timeTakenSeconds)&#10;            put(COLUMN_RESULT_CREATED_AT, testResult.timestamp)&#10;        }&#10;        val id = db.insert(TABLE_TEST_RESULTS, null, values)&#10;        return id&#10;    }&#10;&#10;    @SuppressLint(&quot;Range&quot;)&#10;    fun getTestResults(testId: Int): List&lt;TestResult&gt; {&#10;        val testResults = mutableListOf&lt;TestResult&gt;()&#10;        val db = readableDatabase&#10;        val cursor = db.rawQuery(&quot;SELECT * FROM $TABLE_TEST_RESULTS WHERE $COLUMN_RESULT_TEST_ID = ? ORDER BY $COLUMN_RESULT_CREATED_AT DESC&quot;, arrayOf(testId.toString()))&#10;        if (cursor.moveToFirst()) {&#10;            do {&#10;                val testResult = TestResult(&#10;                    id = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_RESULT_ID)),&#10;                    testId = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_RESULT_TEST_ID)),&#10;                    score = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_SCORE)),&#10;                    timeTakenSeconds = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_TIME_TAKEN_SECONDS)),&#10;                    timestamp = cursor.getLong(cursor.getColumnIndexOrThrow(COLUMN_RESULT_CREATED_AT))&#10;                )&#10;                testResults.add(testResult)&#10;            } while (cursor.moveToNext())&#10;        }&#10;        cursor.close()&#10;        return testResults&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.da.database&#10;&#10;import android.annotation.SuppressLint&#10;import android.content.ContentValues&#10;import android.content.Context&#10;import android.database.sqlite.SQLiteDatabase&#10;import android.database.sqlite.SQLiteOpenHelper&#10;import com.example.da.model.Answer&#10;import com.example.da.model.Question&#10;import com.example.da.model.Subject&#10;import com.example.da.model.Test&#10;import com.example.da.model.TestResult&#10;&#10;class DatabaseHelper(context: Context) : SQLiteOpenHelper(context, DATABASE_NAME, null, DATABASE_VERSION) {&#10;&#10;    companion object {&#10;        private const val DATABASE_NAME = &quot;QuizApp.db&quot;&#10;        private const val DATABASE_VERSION = 5 // Incremented to trigger onUpgrade&#10;&#10;        // Table Subjects&#10;        private const val TABLE_SUBJECTS = &quot;subjects&quot;&#10;        private const val COLUMN_ID = &quot;id&quot;&#10;        private const val COLUMN_NAME = &quot;name&quot;&#10;        private const val COLUMN_CREATED_AT = &quot;created_at&quot;&#10;&#10;        // Table Questions&#10;        private const val TABLE_QUESTIONS = &quot;questions&quot;&#10;        private const val COLUMN_QUESTION_ID = &quot;question_id&quot;&#10;        private const val COLUMN_SUBJECT_ID = &quot;subject_id&quot;&#10;        private const val COLUMN_QUESTION_TEXT = &quot;question_text&quot;&#10;        private const val COLUMN_DIFFICULTY = &quot;difficulty&quot;&#10;        private const val COLUMN_IS_MULTIPLE_CHOICE = &quot;is_multiple_choice&quot;&#10;&#10;        // Table Answers&#10;        private const val TABLE_ANSWERS = &quot;answers&quot;&#10;        private const val COLUMN_ANSWER_ID = &quot;answer_id&quot;&#10;        private const val COLUMN_ANSWER_QUESTION_ID = &quot;question_id&quot;&#10;        private const val COLUMN_ANSWER_TEXT = &quot;answer_text&quot;&#10;        private const val COLUMN_IS_CORRECT = &quot;is_correct&quot;&#10;&#10;        // Table Tests&#10;        private const val TABLE_TESTS = &quot;tests&quot;&#10;        private const val COLUMN_TEST_ID = &quot;test_id&quot;&#10;        private const val COLUMN_TEST_SUBJECT_ID = &quot;subject_id&quot;&#10;        private const val COLUMN_TEST_NAME = &quot;name&quot;&#10;        private const val COLUMN_NUM_QUESTIONS = &quot;num_questions&quot;&#10;        private const val COLUMN_DURATION_MINUTES = &quot;duration_minutes&quot;&#10;        private const val COLUMN_ALLOW_MULTIPLE_ANSWERS = &quot;allow_multiple_answers&quot;&#10;        private const val COLUMN_EASY_PERCENT = &quot;easy_percent&quot;&#10;        private const val COLUMN_MEDIUM_PERCENT = &quot;medium_percent&quot;&#10;        private const val COLUMN_HARD_PERCENT = &quot;hard_percent&quot;&#10;        private const val COLUMN_TEST_CREATED_AT = &quot;created_at&quot;&#10;&#10;        // Table TestResults&#10;        private const val TABLE_TEST_RESULTS = &quot;test_results&quot;&#10;        private const val COLUMN_RESULT_ID = &quot;result_id&quot;&#10;        private const val COLUMN_RESULT_TEST_ID = &quot;test_id&quot;&#10;        private const val COLUMN_SCORE = &quot;score&quot;&#10;        private const val COLUMN_TIME_TAKEN_SECONDS = &quot;time_taken_seconds&quot;&#10;        private const val COLUMN_RESULT_CREATED_AT = &quot;created_at&quot;&#10;    }&#10;&#10;    override fun onCreate(db: SQLiteDatabase?) {&#10;        val createSubjectsTable = &quot;&quot;&quot;&#10;            CREATE TABLE $TABLE_SUBJECTS (&#10;                $COLUMN_ID INTEGER PRIMARY KEY AUTOINCREMENT,&#10;                $COLUMN_NAME TEXT NOT NULL UNIQUE,&#10;                $COLUMN_CREATED_AT INTEGER NOT NULL&#10;            )&#10;        &quot;&quot;&quot;.trimIndent()&#10;&#10;        val createQuestionsTable = &quot;&quot;&quot;&#10;            CREATE TABLE $TABLE_QUESTIONS (&#10;                $COLUMN_QUESTION_ID INTEGER PRIMARY KEY AUTOINCREMENT,&#10;                $COLUMN_SUBJECT_ID INTEGER NOT NULL,&#10;                $COLUMN_QUESTION_TEXT TEXT NOT NULL,&#10;                $COLUMN_DIFFICULTY TEXT NOT NULL,&#10;                $COLUMN_IS_MULTIPLE_CHOICE INTEGER NOT NULL,&#10;                FOREIGN KEY($COLUMN_SUBJECT_ID) REFERENCES $TABLE_SUBJECTS($COLUMN_ID)&#10;            )&#10;        &quot;&quot;&quot;.trimIndent()&#10;&#10;        val createAnswersTable = &quot;&quot;&quot;&#10;            CREATE TABLE $TABLE_ANSWERS (&#10;                $COLUMN_ANSWER_ID INTEGER PRIMARY KEY AUTOINCREMENT,&#10;                $COLUMN_ANSWER_QUESTION_ID INTEGER NOT NULL,&#10;                $COLUMN_ANSWER_TEXT TEXT NOT NULL,&#10;                $COLUMN_IS_CORRECT INTEGER NOT NULL,&#10;                FOREIGN KEY($COLUMN_ANSWER_QUESTION_ID) REFERENCES $TABLE_QUESTIONS($COLUMN_QUESTION_ID)&#10;            )&#10;        &quot;&quot;&quot;.trimIndent()&#10;&#10;        val createTestsTable = &quot;&quot;&quot;&#10;            CREATE TABLE $TABLE_TESTS (&#10;                $COLUMN_TEST_ID INTEGER PRIMARY KEY AUTOINCREMENT,&#10;                $COLUMN_TEST_SUBJECT_ID INTEGER NOT NULL,&#10;                $COLUMN_TEST_NAME TEXT NOT NULL,&#10;                $COLUMN_NUM_QUESTIONS INTEGER NOT NULL,&#10;                $COLUMN_DURATION_MINUTES INTEGER NOT NULL,&#10;                $COLUMN_ALLOW_MULTIPLE_ANSWERS INTEGER NOT NULL,&#10;                $COLUMN_EASY_PERCENT INTEGER NOT NULL,&#10;                $COLUMN_MEDIUM_PERCENT INTEGER NOT NULL,&#10;                $COLUMN_HARD_PERCENT INTEGER NOT NULL,&#10;                $COLUMN_TEST_CREATED_AT INTEGER NOT NULL,&#10;                FOREIGN KEY($COLUMN_TEST_SUBJECT_ID) REFERENCES $TABLE_SUBJECTS($COLUMN_ID)&#10;            )&#10;        &quot;&quot;&quot;.trimIndent()&#10;&#10;        val createTestResultsTable = &quot;&quot;&quot;&#10;            CREATE TABLE $TABLE_TEST_RESULTS (&#10;                $COLUMN_RESULT_ID INTEGER PRIMARY KEY AUTOINCREMENT,&#10;                $COLUMN_RESULT_TEST_ID INTEGER NOT NULL,&#10;                $COLUMN_SCORE INTEGER NOT NULL,&#10;                $COLUMN_TIME_TAKEN_SECONDS INTEGER NOT NULL,&#10;                $COLUMN_RESULT_CREATED_AT INTEGER NOT NULL,&#10;                FOREIGN KEY($COLUMN_RESULT_TEST_ID) REFERENCES $TABLE_TESTS($COLUMN_TEST_ID)&#10;            )&#10;        &quot;&quot;&quot;.trimIndent()&#10;&#10;        db?.execSQL(createSubjectsTable)&#10;        db?.execSQL(createQuestionsTable)&#10;        db?.execSQL(createAnswersTable)&#10;        db?.execSQL(createTestsTable)&#10;        db?.execSQL(createTestResultsTable)&#10;        addSampleData(db)&#10;    }&#10;&#10;    override fun onUpgrade(db: SQLiteDatabase?, oldVersion: Int, newVersion: Int) {&#10;        db?.execSQL(&quot;DROP TABLE IF EXISTS $TABLE_ANSWERS&quot;)&#10;        db?.execSQL(&quot;DROP TABLE IF EXISTS $TABLE_QUESTIONS&quot;)&#10;        db?.execSQL(&quot;DROP TABLE IF EXISTS $TABLE_TESTS&quot;)&#10;        db?.execSQL(&quot;DROP TABLE IF EXISTS $TABLE_TEST_RESULTS&quot;)&#10;        db?.execSQL(&quot;DROP TABLE IF EXISTS $TABLE_SUBJECTS&quot;)&#10;        onCreate(db)&#10;    }&#10;&#10;    private fun addSampleData(db: SQLiteDatabase?) {&#10;        // Add sample subjects&#10;        val sampleSubjects = listOf(&quot;Toán&quot;, &quot;Vật Lý&quot;, &quot;Hóa Học&quot;, &quot;Tiếng Anh&quot;)&#10;        val subjectIds = mutableListOf&lt;Long&gt;()&#10;        sampleSubjects.forEach { subjectName -&gt;&#10;            val values = ContentValues().apply {&#10;                put(COLUMN_NAME, subjectName)&#10;                put(COLUMN_CREATED_AT, System.currentTimeMillis())&#10;            }&#10;            val id = db?.insert(TABLE_SUBJECTS, null, values)&#10;            id?.let { subjectIds.add(it) }&#10;        }&#10;&#10;        // Add sample tests if subjects were added&#10;        if (subjectIds.isNotEmpty()) {&#10;            val test1 = ContentValues().apply {&#10;                put(COLUMN_TEST_SUBJECT_ID, subjectIds[0]) // Toán&#10;                put(COLUMN_TEST_NAME, &quot;Đề kiểm tra giữa kỳ Toán&quot;)&#10;                put(COLUMN_NUM_QUESTIONS, 15)&#10;                put(COLUMN_DURATION_MINUTES, 45)&#10;                put(COLUMN_ALLOW_MULTIPLE_ANSWERS, 0)&#10;                put(COLUMN_EASY_PERCENT, 40)&#10;                put(COLUMN_MEDIUM_PERCENT, 40)&#10;                put(COLUMN_HARD_PERCENT, 20)&#10;                put(COLUMN_TEST_CREATED_AT, System.currentTimeMillis())&#10;            }&#10;            db?.insert(TABLE_TESTS, null, test1)&#10;&#10;            val test2 = ContentValues().apply {&#10;                put(COLUMN_TEST_SUBJECT_ID, subjectIds[1]) // Vật Lý&#10;                put(COLUMN_TEST_NAME, &quot;Đề thi cuối kỳ Vật Lý&quot;)&#10;                put(COLUMN_NUM_QUESTIONS, 20)&#10;                put(COLUMN_DURATION_MINUTES, 60)&#10;                put(COLUMN_ALLOW_MULTIPLE_ANSWERS, 0)&#10;                put(COLUMN_EASY_PERCENT, 30)&#10;                put(COLUMN_MEDIUM_PERCENT, 50)&#10;                put(COLUMN_HARD_PERCENT, 20)&#10;                put(COLUMN_TEST_CREATED_AT, System.currentTimeMillis())&#10;            }&#10;            db?.insert(TABLE_TESTS, null, test2)&#10;        }&#10;    }&#10;&#10;    fun addSubject(subject: Subject): Long {&#10;        val db = writableDatabase&#10;        val values = ContentValues().apply {&#10;            put(COLUMN_NAME, subject.name)&#10;            put(COLUMN_CREATED_AT, System.currentTimeMillis())&#10;        }&#10;        val id = db.insert(TABLE_SUBJECTS, null, values)&#10;        return id&#10;    }&#10;&#10;    @SuppressLint(&quot;Range&quot;)&#10;    fun getAllSubjects(): List&lt;Subject&gt; {&#10;        val subjects = mutableListOf&lt;Subject&gt;()&#10;        val db = readableDatabase&#10;        val cursor = db.rawQuery(&quot;SELECT * FROM $TABLE_SUBJECTS ORDER BY $COLUMN_CREATED_AT DESC&quot;, null)&#10;        if (cursor.moveToFirst()) {&#10;            do {&#10;                val subject = Subject(&#10;                    id = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_ID)),&#10;                    name = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_NAME)),&#10;                    createdAt = cursor.getLong(cursor.getColumnIndexOrThrow(COLUMN_CREATED_AT))&#10;                )&#10;                subjects.add(subject)&#10;            } while (cursor.moveToNext())&#10;        }&#10;        cursor.close()&#10;        return subjects&#10;    }&#10;&#10;    fun deleteSubject(id: Int): Int {&#10;        val db = writableDatabase&#10;        val result = db.delete(TABLE_SUBJECTS, &quot;$COLUMN_ID = ?&quot;, arrayOf(id.toString()))&#10;        return result&#10;    }&#10;&#10;    fun updateSubject(id: Int, newName: String): Int {&#10;        val db = writableDatabase&#10;        val values = ContentValues().apply {&#10;            put(COLUMN_NAME, newName)&#10;        }&#10;        return db.update(TABLE_SUBJECTS, values, &quot;$COLUMN_ID = ?&quot;, arrayOf(id.toString()))&#10;    }&#10;&#10;    fun deleteSubjectAndQuestions(subjectId: Int) {&#10;        val db = writableDatabase&#10;        db.beginTransaction()&#10;        try {&#10;            // First, delete all questions (and their answers) associated with the subject&#10;            val questions = getQuestionsBySubject(subjectId)&#10;            for (question in questions) {&#10;                deleteQuestion(question.id)&#10;            }&#10;&#10;            // Then, delete the subject itself&#10;            deleteSubject(subjectId)&#10;&#10;            db.setTransactionSuccessful()&#10;        } finally {&#10;            db.endTransaction()&#10;        }&#10;    }&#10;&#10;    @SuppressLint(&quot;Range&quot;)&#10;    fun isSubjectExists(name: String): Boolean {&#10;        val db = readableDatabase&#10;        val query = &quot;SELECT COUNT(*) FROM $TABLE_SUBJECTS WHERE $COLUMN_NAME = ?&quot;&#10;        val cursor = db.rawQuery(query, arrayOf(name))&#10;        var exists = false&#10;        if (cursor.moveToFirst()) {&#10;            exists = cursor.getInt(0) &gt; 0&#10;        }&#10;        cursor.close()&#10;        return exists&#10;    }&#10;&#10;    fun deleteQuestion(questionId: Int): Int {&#10;        val db = writableDatabase&#10;        db.delete(TABLE_ANSWERS, &quot;$COLUMN_ANSWER_QUESTION_ID = ?&quot;, arrayOf(questionId.toString()))&#10;        val result = db.delete(TABLE_QUESTIONS, &quot;$COLUMN_QUESTION_ID = ?&quot;, arrayOf(questionId.toString()))&#10;        return result&#10;    }&#10;&#10;    fun addQuestion(subjectId: Int, questionText: String, difficulty: String, isMultipleChoice: Boolean, answers: List&lt;Pair&lt;String, Boolean&gt;&gt;): Long {&#10;        val db = writableDatabase&#10;        val questionValues = ContentValues().apply {&#10;            put(COLUMN_SUBJECT_ID, subjectId)&#10;            put(COLUMN_QUESTION_TEXT, questionText)&#10;            put(COLUMN_DIFFICULTY, difficulty)&#10;            put(COLUMN_IS_MULTIPLE_CHOICE, if (isMultipleChoice) 1 else 0)&#10;        }&#10;        val questionId = db.insert(TABLE_QUESTIONS, null, questionValues)&#10;&#10;        if (questionId &gt; 0) {&#10;            for ((answerText, isCorrect) in answers) {&#10;                val answerValues = ContentValues().apply {&#10;                    put(COLUMN_ANSWER_QUESTION_ID, questionId)&#10;                    put(COLUMN_ANSWER_TEXT, answerText)&#10;                    put(COLUMN_IS_CORRECT, if (isCorrect) 1 else 0)&#10;                }&#10;                db.insert(TABLE_ANSWERS, null, answerValues)&#10;            }&#10;        }&#10;        return questionId&#10;    }&#10;&#10;    @SuppressLint(&quot;Range&quot;)&#10;    fun getQuestionsBySubject(subjectId: Int): List&lt;Question&gt; {&#10;        val questions = mutableListOf&lt;Question&gt;()&#10;        val db = readableDatabase&#10;        val cursor = db.rawQuery(&quot;SELECT * FROM $TABLE_QUESTIONS WHERE $COLUMN_SUBJECT_ID = ?&quot;, arrayOf(subjectId.toString()))&#10;        if (cursor.moveToFirst()) {&#10;            do {&#10;                val question = Question(&#10;                    id = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_QUESTION_ID)),&#10;                    subjectId = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_SUBJECT_ID)),&#10;                    text = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_QUESTION_TEXT)),&#10;                    difficulty = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_DIFFICULTY)),&#10;                    isMultipleChoice = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_IS_MULTIPLE_CHOICE)) == 1&#10;                )&#10;                questions.add(question)&#10;            } while (cursor.moveToNext())&#10;        }&#10;        cursor.close()&#10;        return questions&#10;    }&#10;&#10;    fun addTest(test: Test): Long {&#10;        val db = writableDatabase&#10;        val values = ContentValues().apply {&#10;            put(COLUMN_TEST_SUBJECT_ID, test.subjectId)&#10;            put(COLUMN_TEST_NAME, test.name)&#10;            put(COLUMN_NUM_QUESTIONS, test.numQuestions)&#10;            put(COLUMN_DURATION_MINUTES, test.durationMinutes)&#10;            put(COLUMN_ALLOW_MULTIPLE_ANSWERS, if (test.allowMultipleAnswers) 1 else 0)&#10;            put(COLUMN_EASY_PERCENT, test.easyPercent)&#10;            put(COLUMN_MEDIUM_PERCENT, test.mediumPercent)&#10;            put(COLUMN_HARD_PERCENT, test.hardPercent)&#10;            put(COLUMN_TEST_CREATED_AT, test.createdAt)&#10;        }&#10;        val id = db.insert(TABLE_TESTS, null, values)&#10;        return id&#10;    }&#10;&#10;    @SuppressLint(&quot;Range&quot;)&#10;    fun getAllTests(): List&lt;Test&gt; {&#10;        val tests = mutableListOf&lt;Test&gt;()&#10;        val db = readableDatabase&#10;        val query = &quot;&quot;&quot;&#10;            SELECT t.*, s.$COLUMN_NAME as subject_name&#10;            FROM $TABLE_TESTS t &#10;            JOIN $TABLE_SUBJECTS s ON t.$COLUMN_TEST_SUBJECT_ID = s.$COLUMN_ID &#10;            ORDER BY t.$COLUMN_TEST_CREATED_AT DESC&#10;        &quot;&quot;&quot;.trimIndent()&#10;&#10;        val cursor = db.rawQuery(query, null)&#10;&#10;        if (cursor.moveToFirst()) {&#10;            do {&#10;                val test = Test(&#10;                    testId = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_TEST_ID)),&#10;                    subjectId = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_TEST_SUBJECT_ID)),&#10;                    name = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_TEST_NAME)),&#10;                    numQuestions = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_NUM_QUESTIONS)),&#10;                    durationMinutes = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_DURATION_MINUTES)),&#10;                    allowMultipleAnswers = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_ALLOW_MULTIPLE_ANSWERS)) == 1,&#10;                    easyPercent = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_EASY_PERCENT)),&#10;                    mediumPercent = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_MEDIUM_PERCENT)),&#10;                    hardPercent = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_HARD_PERCENT)),&#10;                    createdAt = cursor.getLong(cursor.getColumnIndexOrThrow(COLUMN_TEST_CREATED_AT)),&#10;                    subjectName = cursor.getString(cursor.getColumnIndexOrThrow(&quot;subject_name&quot;))&#10;                )&#10;                tests.add(test)&#10;            } while (cursor.moveToNext())&#10;        }&#10;        cursor.close()&#10;        return tests&#10;    }&#10;&#10;    @SuppressLint(&quot;Range&quot;)&#10;    fun getTestById(testId: Int): Test? {&#10;        val db = readableDatabase&#10;        val query = &quot;&quot;&quot;&#10;            SELECT t.*, s.$COLUMN_NAME as subject_name&#10;            FROM $TABLE_TESTS t &#10;            JOIN $TABLE_SUBJECTS s ON t.$COLUMN_TEST_SUBJECT_ID = s.$COLUMN_ID &#10;            WHERE t.$COLUMN_TEST_ID = ?&#10;        &quot;&quot;&quot;.trimIndent()&#10;        val cursor = db.rawQuery(query, arrayOf(testId.toString()))&#10;        var test: Test? = null&#10;        if (cursor.moveToFirst()) {&#10;            test = Test(&#10;                testId = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_TEST_ID)),&#10;                subjectId = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_TEST_SUBJECT_ID)),&#10;                name = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_TEST_NAME)),&#10;                numQuestions = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_NUM_QUESTIONS)),&#10;                durationMinutes = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_DURATION_MINUTES)),&#10;                allowMultipleAnswers = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_ALLOW_MULTIPLE_ANSWERS)) == 1,&#10;                easyPercent = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_EASY_PERCENT)),&#10;                mediumPercent = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_MEDIUM_PERCENT)),&#10;                hardPercent = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_HARD_PERCENT)),&#10;                createdAt = cursor.getLong(cursor.getColumnIndexOrThrow(COLUMN_TEST_CREATED_AT)),&#10;                subjectName = cursor.getString(cursor.getColumnIndexOrThrow(&quot;subject_name&quot;))&#10;            )&#10;        }&#10;        cursor.close()&#10;        return test&#10;    }&#10;&#10;    @SuppressLint(&quot;Range&quot;)&#10;    fun getQuestionsForTest(test: Test): List&lt;Question&gt; {&#10;        val questions = mutableListOf&lt;Question&gt;()&#10;        val db = readableDatabase&#10;&#10;        val numEasy = (test.numQuestions * (test.easyPercent / 100.0)).toInt()&#10;        val numMedium = (test.numQuestions * (test.mediumPercent / 100.0)).toInt()&#10;        val numHard = test.numQuestions - numEasy - numMedium&#10;&#10;        val easyQuestions = getQuestionsByDifficulty(db, test.subjectId, &quot;Dễ&quot;, numEasy)&#10;        val mediumQuestions = getQuestionsByDifficulty(db, test.subjectId, &quot;Trung bình&quot;, numMedium)&#10;        val hardQuestions = getQuestionsByDifficulty(db, test.subjectId, &quot;Khó&quot;, numHard)&#10;&#10;        questions.addAll(easyQuestions)&#10;        questions.addAll(mediumQuestions)&#10;        questions.addAll(hardQuestions)&#10;&#10;        return questions.shuffled()&#10;    }&#10;&#10;    @SuppressLint(&quot;Range&quot;)&#10;    private fun getQuestionsByDifficulty(db: SQLiteDatabase, subjectId: Int, difficulty: String, limit: Int): List&lt;Question&gt; {&#10;        val questions = mutableListOf&lt;Question&gt;()&#10;        val query = &quot;SELECT * FROM $TABLE_QUESTIONS WHERE $COLUMN_SUBJECT_ID = ? AND $COLUMN_DIFFICULTY = ? ORDER BY RANDOM() LIMIT ?&quot;&#10;        val cursor = db.rawQuery(query, arrayOf(subjectId.toString(), difficulty, limit.toString()))&#10;        if (cursor.moveToFirst()) {&#10;            do {&#10;                val question = Question(&#10;                    id = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_QUESTION_ID)),&#10;                    subjectId = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_SUBJECT_ID)),&#10;                    text = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_QUESTION_TEXT)),&#10;                    difficulty = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_DIFFICULTY)),&#10;                    isMultipleChoice = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_IS_MULTIPLE_CHOICE)) == 1&#10;                )&#10;                questions.add(question)&#10;            } while (cursor.moveToNext())&#10;        }&#10;        cursor.close()&#10;        return questions&#10;    }&#10;&#10;    @SuppressLint(&quot;Range&quot;)&#10;    fun getAnswersByQuestion(questionId: Int): List&lt;Answer&gt; {&#10;        val answers = mutableListOf&lt;Answer&gt;()&#10;        val db = readableDatabase&#10;        val cursor = db.rawQuery(&quot;SELECT * FROM $TABLE_ANSWERS WHERE $COLUMN_ANSWER_QUESTION_ID = ?&quot;, arrayOf(questionId.toString()))&#10;        if (cursor.moveToFirst()) {&#10;            do {&#10;                val answer = Answer(&#10;                    id = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_ANSWER_ID)),&#10;                    questionId = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_ANSWER_QUESTION_ID)),&#10;                    answerText = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_ANSWER_TEXT)),&#10;                    isCorrect = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_IS_CORRECT)) == 1&#10;                )&#10;                answers.add(answer)&#10;            } while (cursor.moveToNext())&#10;        }&#10;        cursor.close()&#10;        return answers&#10;    }&#10;&#10;    fun addTestResult(testResult: TestResult): Long {&#10;        val db = writableDatabase&#10;        val values = ContentValues().apply {&#10;            put(COLUMN_RESULT_TEST_ID, testResult.testId)&#10;            put(COLUMN_SCORE, testResult.score)&#10;            put(COLUMN_TIME_TAKEN_SECONDS, testResult.timeTakenSeconds)&#10;            put(COLUMN_RESULT_CREATED_AT, testResult.timestamp)&#10;        }&#10;        val id = db.insert(TABLE_TEST_RESULTS, null, values)&#10;        return id&#10;    }&#10;&#10;    @SuppressLint(&quot;Range&quot;)&#10;    fun getTestResults(testId: Int): List&lt;TestResult&gt; {&#10;        val testResults = mutableListOf&lt;TestResult&gt;()&#10;        val db = readableDatabase&#10;        val cursor = db.rawQuery(&quot;SELECT * FROM $TABLE_TEST_RESULTS WHERE $COLUMN_RESULT_TEST_ID = ? ORDER BY $COLUMN_RESULT_CREATED_AT DESC&quot;, arrayOf(testId.toString()))&#10;        if (cursor.moveToFirst()) {&#10;            do {&#10;                val testResult = TestResult(&#10;                    id = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_RESULT_ID)),&#10;                    testId = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_RESULT_TEST_ID)),&#10;                    score = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_SCORE)),&#10;                    timeTakenSeconds = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_TIME_TAKEN_SECONDS)),&#10;                    timestamp = cursor.getLong(cursor.getColumnIndexOrThrow(COLUMN_RESULT_CREATED_AT))&#10;                )&#10;                testResults.add(testResult)&#10;            } while (cursor.moveToNext())&#10;        }&#10;        cursor.close()&#10;        return testResults&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/da/fragment/ManagementFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/da/fragment/ManagementFragment.kt" />
              <option name="originalContent" value="package com.example.da.fragment&#10;&#10;import android.os.Bundle&#10;import androidx.fragment.app.Fragment&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.LinearLayout&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.core.content.ContextCompat&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.da.R&#10;import com.example.da.adapter.QuestionAdapter&#10;import com.example.da.database.DatabaseHelper&#10;import com.example.da.model.Question&#10;import com.example.da.model.Subject&#10;import com.google.android.material.button.MaterialButton&#10;&#10;class ManagementFragment : Fragment() {&#10;    private lateinit var adapter: QuestionAdapter&#10;    private lateinit var dbHelper: DatabaseHelper&#10;    private val allQuestions = mutableListOf&lt;Question&gt;()&#10;    private val subjectsList = mutableListOf&lt;Subject&gt;()&#10;    private val tabViews = mutableListOf&lt;TextView&gt;()&#10;    private var currentSubjectId: Int = -1 // -1 = Tất cả&#10;&#10;    private lateinit var tabContainer: LinearLayout&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater, container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        return inflater.inflate(R.layout.fragment_management, container, false)&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;&#10;        try {&#10;            // Initialize database&#10;            dbHelper = DatabaseHelper(requireContext())&#10;&#10;            val btnCreate = view.findViewById&lt;MaterialButton&gt;(R.id.btnCreateQuestion)&#10;            val ivAdd = view.findViewById&lt;MaterialButton&gt;(R.id.ivAddQuestion)&#10;            val rv = view.findViewById&lt;RecyclerView&gt;(R.id.rvQuestions)&#10;            tabContainer = view.findViewById&lt;LinearLayout&gt;(R.id.tabContainer)&#10;&#10;            // Load subjects from database&#10;            loadSubjects()&#10;&#10;            // Create dynamic tabs&#10;            createDynamicTabs()&#10;&#10;            // Setup RecyclerView&#10;            adapter = QuestionAdapter(allQuestions) { question -&gt;&#10;                try {&#10;                    // Delete question&#10;                    dbHelper.deleteQuestion(question.id)&#10;                    loadQuestionsForCurrentTab()&#10;                    Toast.makeText(requireContext(), &quot;Đã xóa câu hỏi&quot;, Toast.LENGTH_SHORT).show()&#10;                } catch (e: Exception) {&#10;                    Toast.makeText(requireContext(), &quot;Lỗi khi xóa: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;            }&#10;            rv.layoutManager = LinearLayoutManager(requireContext())&#10;            rv.adapter = adapter&#10;&#10;            // Load questions for &quot;Tất cả&quot; tab initially&#10;            loadQuestionsForCurrentTab()&#10;&#10;            btnCreate?.setOnClickListener { navigateToCreate(TaoCauHoiFragment()) }&#10;            ivAdd?.setOnClickListener { navigateToCreate(TaoMonHocFragment()) }&#10;        } catch (e: Exception) {&#10;            Toast.makeText(requireContext(), &quot;Lỗi khởi tạo: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;            e.printStackTrace()&#10;        }&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        // Only reload if adapter is initialized&#10;        if (::adapter.isInitialized &amp;&amp; ::dbHelper.isInitialized) {&#10;            loadSubjects()&#10;            createDynamicTabs()&#10;            loadQuestionsForCurrentTab()&#10;        }&#10;    }&#10;&#10;    private fun loadSubjects() {&#10;        subjectsList.clear()&#10;        subjectsList.addAll(dbHelper.getAllSubjects())&#10;    }&#10;&#10;    private fun createDynamicTabs() {&#10;        tabContainer.removeAllViews()&#10;        tabViews.clear()&#10;&#10;        // Add &quot;Tất cả&quot; tab&#10;        val allTab = createTabView(&quot;Tất cả&quot;, -1)&#10;        tabContainer.addView(allTab)&#10;        tabViews.add(allTab)&#10;&#10;        // Add tabs for each subject&#10;        for (subject in subjectsList) {&#10;            val tabView = createTabView(subject.name, subject.id)&#10;            tabContainer.addView(tabView)&#10;            tabViews.add(tabView)&#10;        }&#10;&#10;         // Select first tab by default only if adapter is initialized&#10;        if (tabViews.isNotEmpty() &amp;&amp; ::adapter.isInitialized) {&#10;            selectTab(tabViews[0], -1)&#10;        } else if (tabViews.isNotEmpty()) {&#10;            // Just highlight first tab without loading questions&#10;            tabViews[0].setBackgroundResource(R.drawable.tab_selected_bg)&#10;            tabViews[0].setTextColor(ContextCompat.getColor(requireContext(), android.R.color.white))&#10;            currentSubjectId = -1&#10;        }&#10;    }&#10;&#10;    private fun createTabView(text: String, subjectId: Int): TextView {&#10;        val tabView = TextView(requireContext()).apply {&#10;            this.text = text&#10;            setPadding(dpToPx(20), dpToPx(10), dpToPx(20), dpToPx(10))&#10;            textSize = 14f&#10;            setTextColor(ContextCompat.getColor(requireContext(), R.color.black))&#10;            setBackgroundResource(R.drawable.tab_unselected_bg)&#10;&#10;            // Add elevation/shadow&#10;            elevation = dpToPx(2).toFloat()&#10;&#10;            layoutParams = LinearLayout.LayoutParams(&#10;                LinearLayout.LayoutParams.WRAP_CONTENT,&#10;                LinearLayout.LayoutParams.WRAP_CONTENT&#10;            ).apply {&#10;                marginEnd = dpToPx(12)&#10;                topMargin = dpToPx(4)&#10;                bottomMargin = dpToPx(4)&#10;            }&#10;&#10;            // Make text bold&#10;            typeface = android.graphics.Typeface.DEFAULT_BOLD&#10;&#10;            setOnClickListener {&#10;                selectTab(this, subjectId)&#10;            }&#10;        }&#10;        return tabView&#10;    }&#10;&#10;    private fun selectTab(selected: TextView, subjectId: Int) {&#10;        tabViews.forEach { tab -&gt;&#10;            if (tab == selected) {&#10;                // Selected tab - gradient blue background&#10;                tab.setBackgroundResource(R.drawable.tab_selected_bg)&#10;                tab.setTextColor(ContextCompat.getColor(requireContext(), android.R.color.white))&#10;                tab.elevation = dpToPx(6).toFloat()&#10;&#10;                // Scale animation&#10;                tab.animate()&#10;                    .scaleX(1.05f)&#10;                    .scaleY(1.05f)&#10;                    .setDuration(200)&#10;                    .start()&#10;            } else {&#10;                // Unselected tab - light gray background&#10;                tab.setBackgroundResource(R.drawable.tab_unselected_bg)&#10;                tab.setTextColor(ContextCompat.getColor(requireContext(), R.color.black))&#10;                tab.elevation = dpToPx(2).toFloat()&#10;&#10;                // Reset scale&#10;                tab.animate()&#10;                    .scaleX(1.0f)&#10;                    .scaleY(1.0f)&#10;                    .setDuration(200)&#10;                    .start()&#10;            }&#10;        }&#10;        currentSubjectId = subjectId&#10;        loadQuestionsForCurrentTab()&#10;    }&#10;&#10;    private fun loadQuestionsForCurrentTab() {&#10;        // Check if adapter is initialized&#10;        if (!::adapter.isInitialized) {&#10;            return&#10;        }&#10;&#10;        try {&#10;            allQuestions.clear()&#10;&#10;            if (currentSubjectId == -1) {&#10;                // Load all questions from all subjects&#10;                for (subject in subjectsList) {&#10;                    val questions = dbHelper.getQuestionsBySubject(subject.id)&#10;                    allQuestions.addAll(questions)&#10;                }&#10;            } else {&#10;                // Load questions for specific subject&#10;                val questions = dbHelper.getQuestionsBySubject(currentSubjectId)&#10;                allQuestions.addAll(dbHelper.getQuestionsBySubject(currentSubjectId))&#10;            }&#10;&#10;            adapter.updateQuestions(allQuestions.toList())&#10;        } catch (e: Exception) {&#10;            Toast.makeText(requireContext(), &quot;Lỗi tải câu hỏi: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;            e.printStackTrace()&#10;            adapter.updateQuestions(emptyList())&#10;        }&#10;    }&#10;&#10;    private fun dpToPx(dp: Int): Int {&#10;        val density = resources.displayMetrics.density&#10;        return (dp * density).toInt()&#10;    }&#10;&#10;    private fun navigateToCreate(fragment: Fragment) {&#10;        parentFragmentManager.beginTransaction()&#10;            .replace(R.id.fragment_container, fragment)&#10;            .addToBackStack(null)&#10;            .commit()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.da.fragment&#10;&#10;import android.os.Bundle&#10;import androidx.fragment.app.Fragment&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.LinearLayout&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.core.content.ContextCompat&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.da.R&#10;import com.example.da.adapter.QuestionAdapter&#10;import com.example.da.database.DatabaseHelper&#10;import com.example.da.model.Question&#10;import com.example.da.model.Subject&#10;import com.google.android.material.button.MaterialButton&#10;&#10;class ManagementFragment : Fragment() {&#10;    private lateinit var adapter: QuestionAdapter&#10;    private lateinit var dbHelper: DatabaseHelper&#10;    private val allQuestions = mutableListOf&lt;Question&gt;()&#10;    private val subjectsList = mutableListOf&lt;Subject&gt;()&#10;    private val tabViews = mutableListOf&lt;TextView&gt;()&#10;    private var currentSubjectId: Int = -1 // -1 = Tất cả&#10;&#10;    private lateinit var tabContainer: LinearLayout&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater, container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        return inflater.inflate(R.layout.fragment_management, container, false)&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;&#10;        try {&#10;            // Initialize database&#10;            dbHelper = DatabaseHelper(requireContext())&#10;&#10;            val btnCreate = view.findViewById&lt;MaterialButton&gt;(R.id.btnCreateQuestion)&#10;            val ivAdd = view.findViewById&lt;MaterialButton&gt;(R.id.ivAddQuestion)&#10;            val rv = view.findViewById&lt;RecyclerView&gt;(R.id.rvQuestions)&#10;            tabContainer = view.findViewById&lt;LinearLayout&gt;(R.id.tabContainer)&#10;&#10;            // Load subjects from database&#10;            loadSubjects()&#10;&#10;            // Create dynamic tabs&#10;            createDynamicTabs()&#10;&#10;            // Setup RecyclerView&#10;            adapter = QuestionAdapter(allQuestions) { question -&gt;&#10;                try {&#10;                    // Delete question&#10;                    dbHelper.deleteQuestion(question.id)&#10;                    loadQuestionsForCurrentTab()&#10;                    Toast.makeText(requireContext(), &quot;Đã xóa câu hỏi&quot;, Toast.LENGTH_SHORT).show()&#10;                } catch (e: Exception) {&#10;                    Toast.makeText(requireContext(), &quot;Lỗi khi xóa: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;            }&#10;            rv.layoutManager = LinearLayoutManager(requireContext())&#10;            rv.adapter = adapter&#10;&#10;            // Load questions for &quot;Tất cả&quot; tab initially&#10;            loadQuestionsForCurrentTab()&#10;&#10;            btnCreate?.setOnClickListener { navigateToCreate(TaoCauHoiFragment()) }&#10;            ivAdd?.text = &quot;QL Môn&quot; // Change text&#10;            ivAdd?.setOnClickListener { navigateToCreate(SubjectManagementFragment()) }&#10;        } catch (e: Exception) {&#10;            Toast.makeText(requireContext(), &quot;Lỗi khởi tạo: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;            e.printStackTrace()&#10;        }&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        // Only reload if adapter is initialized&#10;        if (::adapter.isInitialized &amp;&amp; ::dbHelper.isInitialized) {&#10;            loadSubjects()&#10;            createDynamicTabs()&#10;            loadQuestionsForCurrentTab()&#10;        }&#10;    }&#10;&#10;    private fun loadSubjects() {&#10;        subjectsList.clear()&#10;        subjectsList.addAll(dbHelper.getAllSubjects())&#10;    }&#10;&#10;    private fun createDynamicTabs() {&#10;        tabContainer.removeAllViews()&#10;        tabViews.clear()&#10;&#10;        // Add &quot;Tất cả&quot; tab&#10;        val allTab = createTabView(&quot;Tất cả&quot;, -1)&#10;        tabContainer.addView(allTab)&#10;        tabViews.add(allTab)&#10;&#10;        // Add tabs for each subject&#10;        for (subject in subjectsList) {&#10;            val tabView = createTabView(subject.name, subject.id)&#10;            tabContainer.addView(tabView)&#10;            tabViews.add(tabView)&#10;        }&#10;&#10;         // Select first tab by default only if adapter is initialized&#10;        if (tabViews.isNotEmpty() &amp;&amp; ::adapter.isInitialized) {&#10;            selectTab(tabViews[0], -1)&#10;        } else if (tabViews.isNotEmpty()) {&#10;            // Just highlight first tab without loading questions&#10;            tabViews[0].setBackgroundResource(R.drawable.tab_selected_bg)&#10;            tabViews[0].setTextColor(ContextCompat.getColor(requireContext(), android.R.color.white))&#10;            currentSubjectId = -1&#10;        }&#10;    }&#10;&#10;    private fun createTabView(text: String, subjectId: Int): TextView {&#10;        val tabView = TextView(requireContext()).apply {&#10;            this.text = text&#10;            setPadding(dpToPx(20), dpToPx(10), dpToPx(20), dpToPx(10))&#10;            textSize = 14f&#10;            setTextColor(ContextCompat.getColor(requireContext(), R.color.black))&#10;            setBackgroundResource(R.drawable.tab_unselected_bg)&#10;&#10;            // Add elevation/shadow&#10;            elevation = dpToPx(2).toFloat()&#10;&#10;            layoutParams = LinearLayout.LayoutParams(&#10;                LinearLayout.LayoutParams.WRAP_CONTENT,&#10;                LinearLayout.LayoutParams.WRAP_CONTENT&#10;            ).apply {&#10;                marginEnd = dpToPx(12)&#10;                topMargin = dpToPx(4)&#10;                bottomMargin = dpToPx(4)&#10;            }&#10;&#10;            // Make text bold&#10;            typeface = android.graphics.Typeface.DEFAULT_BOLD&#10;&#10;            setOnClickListener {&#10;                selectTab(this, subjectId)&#10;            }&#10;        }&#10;        return tabView&#10;    }&#10;&#10;    private fun selectTab(selected: TextView, subjectId: Int) {&#10;        tabViews.forEach { tab -&gt;&#10;            if (tab == selected) {&#10;                // Selected tab - gradient blue background&#10;                tab.setBackgroundResource(R.drawable.tab_selected_bg)&#10;                tab.setTextColor(ContextCompat.getColor(requireContext(), android.R.color.white))&#10;                tab.elevation = dpToPx(6).toFloat()&#10;&#10;                // Scale animation&#10;                tab.animate()&#10;                    .scaleX(1.05f)&#10;                    .scaleY(1.05f)&#10;                    .setDuration(200)&#10;                    .start()&#10;            } else {&#10;                // Unselected tab - light gray background&#10;                tab.setBackgroundResource(R.drawable.tab_unselected_bg)&#10;                tab.setTextColor(ContextCompat.getColor(requireContext(), R.color.black))&#10;                tab.elevation = dpToPx(2).toFloat()&#10;&#10;                // Reset scale&#10;                tab.animate()&#10;                    .scaleX(1.0f)&#10;                    .scaleY(1.0f)&#10;                    .setDuration(200)&#10;                    .start()&#10;            }&#10;        }&#10;        currentSubjectId = subjectId&#10;        loadQuestionsForCurrentTab()&#10;    }&#10;&#10;    private fun loadQuestionsForCurrentTab() {&#10;        // Check if adapter is initialized&#10;        if (!::adapter.isInitialized) {&#10;            return&#10;        }&#10;&#10;        try {&#10;            allQuestions.clear()&#10;&#10;            if (currentSubjectId == -1) {&#10;                // Load all questions from all subjects&#10;                for (subject in subjectsList) {&#10;                    val questions = dbHelper.getQuestionsBySubject(subject.id)&#10;                    allQuestions.addAll(questions)&#10;                }&#10;            } else {&#10;                // Load questions for specific subject&#10;                val questions = dbHelper.getQuestionsBySubject(currentSubjectId)&#10;                allQuestions.addAll(dbHelper.getQuestionsBySubject(currentSubjectId))&#10;            }&#10;&#10;            adapter.updateQuestions(allQuestions.toList())&#10;        } catch (e: Exception) {&#10;            Toast.makeText(requireContext(), &quot;Lỗi tải câu hỏi: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;            e.printStackTrace()&#10;            adapter.updateQuestions(emptyList())&#10;        }&#10;    }&#10;&#10;    private fun dpToPx(dp: Int): Int {&#10;        val density = resources.displayMetrics.density&#10;        return (dp * density).toInt()&#10;    }&#10;&#10;    private fun navigateToCreate(fragment: Fragment) {&#10;        parentFragmentManager.beginTransaction()&#10;            .replace(R.id.fragment_container, fragment)&#10;            .addToBackStack(null)&#10;            .commit()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/da/fragment/SubjectManagementFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/da/fragment/SubjectManagementFragment.kt" />
              <option name="updatedContent" value="package com.example.da.fragment&#10;&#10;import android.os.Bundle&#10;import androidx.fragment.app.Fragment&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.EditText&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.da.R&#10;import com.example.da.adapter.SubjectAdapter&#10;import com.example.da.database.DatabaseHelper&#10;import com.example.da.model.Subject&#10;&#10;class SubjectManagementFragment : Fragment() {&#10;&#10;    private lateinit var dbHelper: DatabaseHelper&#10;    private lateinit var subjectAdapter: SubjectAdapter&#10;    private val subjectsList = mutableListOf&lt;Subject&gt;()&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater, container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        return inflater.inflate(R.layout.fragment_subject_management, container, false)&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;&#10;        dbHelper = DatabaseHelper(requireContext())&#10;&#10;        val rvSubjects = view.findViewById&lt;RecyclerView&gt;(R.id.rvSubjects)&#10;        val btnAddSubject = view.findViewById&lt;Button&gt;(R.id.btnAddSubject)&#10;&#10;        subjectAdapter = SubjectAdapter(subjectsList,&#10;            onEditClick = { subject -&gt; showEditSubjectDialog(subject) },&#10;            onDeleteClick = { subject -&gt; showDeleteConfirmationDialog(subject) }&#10;        )&#10;&#10;        rvSubjects.layoutManager = LinearLayoutManager(requireContext())&#10;        rvSubjects.adapter = subjectAdapter&#10;&#10;        loadSubjects()&#10;&#10;        btnAddSubject.setOnClickListener {&#10;            showAddSubjectDialog()&#10;        }&#10;    }&#10;&#10;    private fun loadSubjects() {&#10;        subjectsList.clear()&#10;        subjectsList.addAll(dbHelper.getAllSubjects())&#10;        subjectAdapter.updateSubjects(subjectsList)&#10;    }&#10;&#10;    private fun showAddSubjectDialog() {&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        builder.setTitle(&quot;Thêm Môn học&quot;)&#10;&#10;        val input = EditText(requireContext())&#10;        input.hint = &quot;Nhập tên môn học&quot;&#10;        builder.setView(input)&#10;&#10;        builder.setPositiveButton(&quot;Thêm&quot;) { dialog, _ -&gt;&#10;            val subjectName = input.text.toString().trim()&#10;            if (subjectName.isNotEmpty()) {&#10;                if (!dbHelper.isSubjectExists(subjectName)) {&#10;                    val newSubject = Subject(name = subjectName, createdAt = System.currentTimeMillis())&#10;                    dbHelper.addSubject(newSubject)&#10;                    loadSubjects()&#10;                    Toast.makeText(requireContext(), &quot;Đã thêm môn học&quot;, Toast.LENGTH_SHORT).show()&#10;                } else {&#10;                    Toast.makeText(requireContext(), &quot;Môn học đã tồn tại&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;            } else {&#10;                Toast.makeText(requireContext(), &quot;Tên môn học không được để trống&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;            dialog.dismiss()&#10;        }&#10;        builder.setNegativeButton(&quot;Hủy&quot;) { dialog, _ -&gt; dialog.cancel() }&#10;&#10;        builder.show()&#10;    }&#10;&#10;    private fun showEditSubjectDialog(subject: Subject) {&#10;        val builder = AlertDialog.Builder(requireContext())&#10;        builder.setTitle(&quot;Sửa tên Môn học&quot;)&#10;&#10;        val input = EditText(requireContext())&#10;        input.setText(subject.name)&#10;        builder.setView(input)&#10;&#10;        builder.setPositiveButton(&quot;Lưu&quot;) { dialog, _ -&gt;&#10;            val newName = input.text.toString().trim()&#10;            if (newName.isNotEmpty()) {&#10;                if (!dbHelper.isSubjectExists(newName) || newName.equals(subject.name, ignoreCase = true)) {&#10;                    dbHelper.updateSubject(subject.id, newName)&#10;                    loadSubjects()&#10;                    Toast.makeText(requireContext(), &quot;Đã cập nhật môn học&quot;, Toast.LENGTH_SHORT).show()&#10;                } else {&#10;                    Toast.makeText(requireContext(), &quot;Tên môn học đã tồn tại&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;            } else {&#10;                Toast.makeText(requireContext(), &quot;Tên môn học không được để trống&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;            dialog.dismiss()&#10;        }&#10;        builder.setNegativeButton(&quot;Hủy&quot;) { dialog, _ -&gt; dialog.cancel() }&#10;&#10;        builder.show()&#10;    }&#10;&#10;    private fun showDeleteConfirmationDialog(subject: Subject) {&#10;        AlertDialog.Builder(requireContext())&#10;            .setTitle(&quot;Xác nhận Xóa&quot;)&#10;            .setMessage(&quot;Bạn có chắc chắn muốn xóa môn học '${subject.name}' không? Tất cả các câu hỏi liên quan cũng sẽ bị xóa.&quot;)&#10;            .setPositiveButton(&quot;Xóa&quot;) { _, _ -&gt;&#10;                dbHelper.deleteSubjectAndQuestions(subject.id)&#10;                loadSubjects()&#10;                Toast.makeText(requireContext(), &quot;Đã xóa môn học&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;            .setNegativeButton(&quot;Hủy&quot;, null)&#10;            .show()&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/fragment_subject_management.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/fragment_subject_management.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    android:orientation=&quot;vertical&quot;&#10;    android:padding=&quot;16dp&quot;&#10;    tools:context=&quot;.fragment.SubjectManagementFragment&quot;&gt;&#10;&#10;    &lt;TextView&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Quản lý Môn học&quot;&#10;        android:textSize=&quot;24sp&quot;&#10;        android:textStyle=&quot;bold&quot;&#10;        android:layout_marginBottom=&quot;16dp&quot;/&gt;&#10;&#10;    &lt;androidx.recyclerview.widget.RecyclerView&#10;        android:id=&quot;@+id/rvSubjects&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        android:layout_weight=&quot;1&quot; /&gt;&#10;&#10;    &lt;Button&#10;        android:id=&quot;@+id/btnAddSubject&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Thêm Môn học mới&quot;&#10;        android:layout_marginTop=&quot;16dp&quot;/&gt;&#10;&#10;&lt;/LinearLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/item_subject.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/item_subject.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:orientation=&quot;horizontal&quot;&#10;    android:padding=&quot;16dp&quot;&#10;    android:gravity=&quot;center_vertical&quot;&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/tvSubjectName&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_weight=&quot;1&quot;&#10;        android:text=&quot;Tên môn học&quot;&#10;        android:textSize=&quot;18sp&quot; /&gt;&#10;&#10;    &lt;Button&#10;        android:id=&quot;@+id/btnEdit&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Sửa&quot;&#10;        android:layout_marginEnd=&quot;8dp&quot;/&gt;&#10;&#10;    &lt;Button&#10;        android:id=&quot;@+id/btnDelete&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Xóa&quot;&#10;        android:backgroundTint=&quot;@android:color/holo_red_light&quot;/&gt;&#10;&#10;&lt;/LinearLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>